// This file is autogenerated.
//
// To add bindings, edit windows_sys.lst then run:
//
// ```
// cd generate-windows-sys/
// cargo run
// ```
// Bindings generated by `windows-bindgen` 0.58.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
#[inline]
pub unsafe fn RegCloseKey<P0>(hkey: P0) -> WIN32_ERROR
where
    P0: windows_core::Param<HKEY>,
{
    windows_targets::link!("advapi32.dll" "system" fn RegCloseKey(hkey : HKEY) -> WIN32_ERROR);
    RegCloseKey(hkey.param().abi())
}
#[inline]
pub unsafe fn RegEnumKeyExW<P0>(
    hkey: P0,
    dwindex: u32,
    lpname: windows_core::PWSTR,
    lpcchname: *mut u32,
    lpreserved: Option<*const u32>,
    lpclass: windows_core::PWSTR,
    lpcchclass: Option<*mut u32>,
    lpftlastwritetime: Option<*mut FILETIME>,
) -> WIN32_ERROR
where
    P0: windows_core::Param<HKEY>,
{
    windows_targets::link!("advapi32.dll" "system" fn RegEnumKeyExW(hkey : HKEY, dwindex : u32, lpname : windows_core::PWSTR, lpcchname : *mut u32, lpreserved : *const u32, lpclass : windows_core::PWSTR, lpcchclass : *mut u32, lpftlastwritetime : *mut FILETIME) -> WIN32_ERROR);
    RegEnumKeyExW(
        hkey.param().abi(),
        dwindex,
        core::mem::transmute(lpname),
        lpcchname,
        core::mem::transmute(lpreserved.unwrap_or(std::ptr::null())),
        core::mem::transmute(lpclass),
        core::mem::transmute(lpcchclass.unwrap_or(std::ptr::null_mut())),
        core::mem::transmute(lpftlastwritetime.unwrap_or(std::ptr::null_mut())),
    )
}
#[inline]
pub unsafe fn RegOpenKeyExW<P0, P1>(
    hkey: P0,
    lpsubkey: P1,
    uloptions: u32,
    samdesired: REG_SAM_FLAGS,
    phkresult: *mut HKEY,
) -> WIN32_ERROR
where
    P0: windows_core::Param<HKEY>,
    P1: windows_core::Param<windows_core::PCWSTR>,
{
    windows_targets::link!("advapi32.dll" "system" fn RegOpenKeyExW(hkey : HKEY, lpsubkey : windows_core::PCWSTR, uloptions : u32, samdesired : REG_SAM_FLAGS, phkresult : *mut HKEY) -> WIN32_ERROR);
    RegOpenKeyExW(
        hkey.param().abi(),
        lpsubkey.param().abi(),
        uloptions,
        samdesired,
        phkresult,
    )
}
#[inline]
pub unsafe fn RegQueryValueExW<P0, P1>(
    hkey: P0,
    lpvaluename: P1,
    lpreserved: Option<*const u32>,
    lptype: Option<*mut REG_VALUE_TYPE>,
    lpdata: Option<*mut u8>,
    lpcbdata: Option<*mut u32>,
) -> WIN32_ERROR
where
    P0: windows_core::Param<HKEY>,
    P1: windows_core::Param<windows_core::PCWSTR>,
{
    windows_targets::link!("advapi32.dll" "system" fn RegQueryValueExW(hkey : HKEY, lpvaluename : windows_core::PCWSTR, lpreserved : *const u32, lptype : *mut REG_VALUE_TYPE, lpdata : *mut u8, lpcbdata : *mut u32) -> WIN32_ERROR);
    RegQueryValueExW(
        hkey.param().abi(),
        lpvaluename.param().abi(),
        core::mem::transmute(lpreserved.unwrap_or(std::ptr::null())),
        core::mem::transmute(lptype.unwrap_or(std::ptr::null_mut())),
        core::mem::transmute(lpdata.unwrap_or(std::ptr::null_mut())),
        core::mem::transmute(lpcbdata.unwrap_or(std::ptr::null_mut())),
    )
}
#[inline]
pub unsafe fn FreeLibrary<P0>(hlibmodule: P0) -> windows_core::Result<()>
where
    P0: windows_core::Param<HMODULE>,
{
    windows_targets::link!("kernel32.dll" "system" fn FreeLibrary(hlibmodule : HMODULE) -> BOOL);
    FreeLibrary(hlibmodule.param().abi()).ok()
}
#[inline]
pub unsafe fn GetMachineTypeAttributes(machine: u16) -> windows_core::Result<MACHINE_ATTRIBUTES> {
    windows_targets::link!("kernel32.dll" "system" fn GetMachineTypeAttributes(machine : u16, machinetypeattributes : *mut MACHINE_ATTRIBUTES) -> windows_core::HRESULT);
    let mut result__ = core::mem::zeroed();
    GetMachineTypeAttributes(machine, &mut result__).map(|| result__)
}
#[inline]
pub unsafe fn GetProcAddress<P0, P1>(hmodule: P0, lpprocname: P1) -> FARPROC
where
    P0: windows_core::Param<HMODULE>,
    P1: windows_core::Param<windows_core::PCSTR>,
{
    windows_targets::link!("kernel32.dll" "system" fn GetProcAddress(hmodule : HMODULE, lpprocname : windows_core::PCSTR) -> FARPROC);
    GetProcAddress(hmodule.param().abi(), lpprocname.param().abi())
}
#[inline]
pub unsafe fn LoadLibraryA<P0>(lplibfilename: P0) -> windows_core::Result<HMODULE>
where
    P0: windows_core::Param<windows_core::PCSTR>,
{
    windows_targets::link!("kernel32.dll" "system" fn LoadLibraryA(lplibfilename : windows_core::PCSTR) -> HMODULE);
    let result__ = LoadLibraryA(lplibfilename.param().abi());
    (!result__.is_invalid())
        .then(|| result__)
        .ok_or_else(windows_core::Error::from_win32)
}
#[inline]
pub unsafe fn OpenSemaphoreA<P0, P1>(dwdesiredaccess: u32, binherithandle: P0, lpname: P1) -> HANDLE
where
    P0: windows_core::Param<BOOL>,
    P1: windows_core::Param<windows_core::PCSTR>,
{
    windows_targets::link!("kernel32.dll" "system" fn OpenSemaphoreA(dwdesiredaccess : u32, binherithandle : BOOL, lpname : windows_core::PCSTR) -> HANDLE);
    OpenSemaphoreA(
        dwdesiredaccess,
        binherithandle.param().abi(),
        lpname.param().abi(),
    )
}
#[inline]
pub unsafe fn PeekNamedPipe<P0>(
    hnamedpipe: P0,
    lpbuffer: Option<*mut core::ffi::c_void>,
    nbuffersize: u32,
    lpbytesread: Option<*mut u32>,
    lptotalbytesavail: Option<*mut u32>,
    lpbytesleftthismessage: Option<*mut u32>,
) -> windows_core::Result<()>
where
    P0: windows_core::Param<HANDLE>,
{
    windows_targets::link!("kernel32.dll" "system" fn PeekNamedPipe(hnamedpipe : HANDLE, lpbuffer : *mut core::ffi::c_void, nbuffersize : u32, lpbytesread : *mut u32, lptotalbytesavail : *mut u32, lpbytesleftthismessage : *mut u32) -> BOOL);
    PeekNamedPipe(
        hnamedpipe.param().abi(),
        core::mem::transmute(lpbuffer.unwrap_or(std::ptr::null_mut())),
        nbuffersize,
        core::mem::transmute(lpbytesread.unwrap_or(std::ptr::null_mut())),
        core::mem::transmute(lptotalbytesavail.unwrap_or(std::ptr::null_mut())),
        core::mem::transmute(lpbytesleftthismessage.unwrap_or(std::ptr::null_mut())),
    )
    .ok()
}
#[inline]
pub unsafe fn ReleaseSemaphore<P0>(
    hsemaphore: P0,
    lreleasecount: i32,
    lppreviouscount: Option<*mut i32>,
) -> windows_core::Result<()>
where
    P0: windows_core::Param<HANDLE>,
{
    windows_targets::link!("kernel32.dll" "system" fn ReleaseSemaphore(hsemaphore : HANDLE, lreleasecount : i32, lppreviouscount : *mut i32) -> BOOL);
    ReleaseSemaphore(
        hsemaphore.param().abi(),
        lreleasecount,
        core::mem::transmute(lppreviouscount.unwrap_or(std::ptr::null_mut())),
    )
    .ok()
}
#[inline]
pub unsafe fn WaitForSingleObject<P0>(hhandle: P0, dwmilliseconds: u32) -> WAIT_EVENT
where
    P0: windows_core::Param<HANDLE>,
{
    windows_targets::link!("kernel32.dll" "system" fn WaitForSingleObject(hhandle : HANDLE, dwmilliseconds : u32) -> WAIT_EVENT);
    WaitForSingleObject(hhandle.param().abi(), dwmilliseconds)
}
#[inline]
pub unsafe fn CoCreateInstance<P0, T>(
    rclsid: *const windows_core::GUID,
    punkouter: P0,
    dwclscontext: CLSCTX,
) -> windows_core::Result<T>
where
    P0: windows_core::Param<windows_core::IUnknown>,
    T: windows_core::Interface,
{
    windows_targets::link!("ole32.dll" "system" fn CoCreateInstance(rclsid : *const windows_core::GUID, punkouter : * mut core::ffi::c_void, dwclscontext : CLSCTX, riid : *const windows_core::GUID, ppv : *mut *mut core::ffi::c_void) -> windows_core::HRESULT);
    let mut result__ = core::ptr::null_mut();
    CoCreateInstance(
        rclsid,
        punkouter.param().abi(),
        dwclscontext,
        &T::IID,
        &mut result__,
    )
    .and_then(|| windows_core::Type::from_abi(result__))
}
#[inline]
pub unsafe fn CoInitializeEx(
    pvreserved: Option<*const core::ffi::c_void>,
    dwcoinit: COINIT,
) -> windows_core::HRESULT {
    windows_targets::link!("ole32.dll" "system" fn CoInitializeEx(pvreserved : *const core::ffi::c_void, dwcoinit : u32) -> windows_core::HRESULT);
    CoInitializeEx(
        core::mem::transmute(pvreserved.unwrap_or(std::ptr::null())),
        dwcoinit.0 as _,
    )
}
#[inline]
pub unsafe fn SysFreeString<P0>(bstrstring: P0)
where
    P0: windows_core::Param<windows_core::BSTR>,
{
    windows_targets::link!("oleaut32.dll" "system" fn SysFreeString(bstrstring : core::mem::MaybeUninit < windows_core::BSTR >));
    SysFreeString(bstrstring.param().abi())
}
#[inline]
pub unsafe fn SysStringLen<P0>(pbstr: P0) -> u32
where
    P0: windows_core::Param<windows_core::BSTR>,
{
    windows_targets::link!("oleaut32.dll" "system" fn SysStringLen(pbstr : core::mem::MaybeUninit < windows_core::BSTR >) -> u32);
    SysStringLen(pbstr.param().abi())
}
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct ADVANCED_FEATURE_FLAGS(pub u16);
impl windows_core::TypeKind for ADVANCED_FEATURE_FLAGS {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for ADVANCED_FEATURE_FLAGS {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("ADVANCED_FEATURE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl ADVANCED_FEATURE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for ADVANCED_FEATURE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for ADVANCED_FEATURE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for ADVANCED_FEATURE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for ADVANCED_FEATURE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for ADVANCED_FEATURE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct BOOL(pub i32);
impl Default for BOOL {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
impl windows_core::TypeKind for BOOL {
    type TypeKind = windows_core::CopyType;
}
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct CLSCTX(pub u32);
impl windows_core::TypeKind for CLSCTX {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for CLSCTX {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("CLSCTX").field(&self.0).finish()
    }
}
impl CLSCTX {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for CLSCTX {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for CLSCTX {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for CLSCTX {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for CLSCTX {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for CLSCTX {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const CLSCTX_ALL: CLSCTX = CLSCTX(23u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct COINIT(pub i32);
impl windows_core::TypeKind for COINIT {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for COINIT {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("COINIT").field(&self.0).finish()
    }
}
impl COINIT {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for COINIT {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for COINIT {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for COINIT {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for COINIT {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for COINIT {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const COINIT_MULTITHREADED: COINIT = COINIT(0i32);
pub const ERROR_NO_MORE_ITEMS: WIN32_ERROR = WIN32_ERROR(259u32);
pub const ERROR_SUCCESS: WIN32_ERROR = WIN32_ERROR(0u32);
pub const FALSE: BOOL = BOOL(0i32);
pub type FARPROC = Option<unsafe extern "system" fn() -> isize>;
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct FILETIME {
    pub dwLowDateTime: u32,
    pub dwHighDateTime: u32,
}
impl windows_core::TypeKind for FILETIME {
    type TypeKind = windows_core::CopyType;
}
impl Default for FILETIME {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const FILE_ATTRIBUTE_TEMPORARY: FILE_FLAGS_AND_ATTRIBUTES = FILE_FLAGS_AND_ATTRIBUTES(256u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct FILE_FLAGS_AND_ATTRIBUTES(pub u32);
impl windows_core::TypeKind for FILE_FLAGS_AND_ATTRIBUTES {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for FILE_FLAGS_AND_ATTRIBUTES {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("FILE_FLAGS_AND_ATTRIBUTES")
            .field(&self.0)
            .finish()
    }
}
impl FILE_FLAGS_AND_ATTRIBUTES {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for FILE_FLAGS_AND_ATTRIBUTES {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for FILE_FLAGS_AND_ATTRIBUTES {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for FILE_FLAGS_AND_ATTRIBUTES {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for FILE_FLAGS_AND_ATTRIBUTES {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for FILE_FLAGS_AND_ATTRIBUTES {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct HANDLE(pub *mut core::ffi::c_void);
impl HANDLE {
    pub fn is_invalid(&self) -> bool {
        self.0 == -1 as _ || self.0 == 0 as _
    }
}
impl windows_core::Free for HANDLE {
    #[inline]
    unsafe fn free(&mut self) {
        if !self.is_invalid() {
            _ = CloseHandle(*self);
        }
    }
}
impl Default for HANDLE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
impl windows_core::TypeKind for HANDLE {
    type TypeKind = windows_core::CopyType;
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct HKEY(pub *mut core::ffi::c_void);
impl HKEY {
    pub fn is_invalid(&self) -> bool {
        self.0 == -1 as _ || self.0 == 0 as _
    }
}
impl windows_core::Free for HKEY {
    #[inline]
    unsafe fn free(&mut self) {
        if !self.is_invalid() {
            _ = RegCloseKey(*self);
        }
    }
}
impl Default for HKEY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
impl windows_core::TypeKind for HKEY {
    type TypeKind = windows_core::CopyType;
}
pub const HKEY_LOCAL_MACHINE: HKEY = HKEY(-2147483646i32 as _);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct HMODULE(pub *mut core::ffi::c_void);
impl HMODULE {
    pub fn is_invalid(&self) -> bool {
        self.0.is_null()
    }
}
impl windows_core::Free for HMODULE {
    #[inline]
    unsafe fn free(&mut self) {
        if !self.is_invalid() {
            _ = FreeLibrary(*self);
        }
    }
}
impl Default for HMODULE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
impl windows_core::TypeKind for HMODULE {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::imp::CanInto<HINSTANCE> for HMODULE {}
impl From<HMODULE> for HINSTANCE {
    fn from(value: HMODULE) -> Self {
        Self(value.0)
    }
}
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct IMAGE_FILE_MACHINE(pub u16);
impl windows_core::TypeKind for IMAGE_FILE_MACHINE {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for IMAGE_FILE_MACHINE {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("IMAGE_FILE_MACHINE").field(&self.0).finish()
    }
}
pub const IMAGE_FILE_MACHINE_AMD64: IMAGE_FILE_MACHINE = IMAGE_FILE_MACHINE(34404u16);
pub const KEY_READ: REG_SAM_FLAGS = REG_SAM_FLAGS(131097u32);
pub const KEY_WOW64_32KEY: REG_SAM_FLAGS = REG_SAM_FLAGS(512u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct MACHINE_ATTRIBUTES(pub i32);
impl windows_core::TypeKind for MACHINE_ATTRIBUTES {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for MACHINE_ATTRIBUTES {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("MACHINE_ATTRIBUTES").field(&self.0).finish()
    }
}
impl MACHINE_ATTRIBUTES {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for MACHINE_ATTRIBUTES {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for MACHINE_ATTRIBUTES {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for MACHINE_ATTRIBUTES {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for MACHINE_ATTRIBUTES {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for MACHINE_ATTRIBUTES {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct REG_SAM_FLAGS(pub u32);
impl windows_core::TypeKind for REG_SAM_FLAGS {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for REG_SAM_FLAGS {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("REG_SAM_FLAGS").field(&self.0).finish()
    }
}
impl REG_SAM_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for REG_SAM_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for REG_SAM_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for REG_SAM_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for REG_SAM_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for REG_SAM_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const REG_SZ: REG_VALUE_TYPE = REG_VALUE_TYPE(1u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct REG_VALUE_TYPE(pub u32);
impl windows_core::TypeKind for REG_VALUE_TYPE {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for REG_VALUE_TYPE {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("REG_VALUE_TYPE").field(&self.0).finish()
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct SAFEARRAY {
    pub cDims: u16,
    pub fFeatures: ADVANCED_FEATURE_FLAGS,
    pub cbElements: u32,
    pub cLocks: u32,
    pub pvData: *mut core::ffi::c_void,
    pub rgsabound: [SAFEARRAYBOUND; 1],
}
impl windows_core::TypeKind for SAFEARRAY {
    type TypeKind = windows_core::CopyType;
}
impl Default for SAFEARRAY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct SAFEARRAYBOUND {
    pub cElements: u32,
    pub lLbound: i32,
}
impl windows_core::TypeKind for SAFEARRAYBOUND {
    type TypeKind = windows_core::CopyType;
}
impl Default for SAFEARRAYBOUND {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const SEMAPHORE_MODIFY_STATE: SYNCHRONIZATION_ACCESS_RIGHTS =
    SYNCHRONIZATION_ACCESS_RIGHTS(2u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct SYNCHRONIZATION_ACCESS_RIGHTS(pub u32);
impl windows_core::TypeKind for SYNCHRONIZATION_ACCESS_RIGHTS {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for SYNCHRONIZATION_ACCESS_RIGHTS {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("SYNCHRONIZATION_ACCESS_RIGHTS")
            .field(&self.0)
            .finish()
    }
}
impl SYNCHRONIZATION_ACCESS_RIGHTS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for SYNCHRONIZATION_ACCESS_RIGHTS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for SYNCHRONIZATION_ACCESS_RIGHTS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for SYNCHRONIZATION_ACCESS_RIGHTS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for SYNCHRONIZATION_ACCESS_RIGHTS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for SYNCHRONIZATION_ACCESS_RIGHTS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const S_FALSE: windows_core::HRESULT = windows_core::HRESULT(0x1_u32 as _);
pub const S_OK: windows_core::HRESULT = windows_core::HRESULT(0x0_u32 as _);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct THREAD_ACCESS_RIGHTS(pub u32);
impl windows_core::TypeKind for THREAD_ACCESS_RIGHTS {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for THREAD_ACCESS_RIGHTS {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("THREAD_ACCESS_RIGHTS")
            .field(&self.0)
            .finish()
    }
}
impl THREAD_ACCESS_RIGHTS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for THREAD_ACCESS_RIGHTS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for THREAD_ACCESS_RIGHTS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for THREAD_ACCESS_RIGHTS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for THREAD_ACCESS_RIGHTS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for THREAD_ACCESS_RIGHTS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const THREAD_SYNCHRONIZE: THREAD_ACCESS_RIGHTS = THREAD_ACCESS_RIGHTS(1048576u32);
pub const UserEnabled: MACHINE_ATTRIBUTES = MACHINE_ATTRIBUTES(1i32);
pub const WAIT_ABANDONED: WAIT_EVENT = WAIT_EVENT(128u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct WAIT_EVENT(pub u32);
impl windows_core::TypeKind for WAIT_EVENT {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for WAIT_EVENT {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("WAIT_EVENT").field(&self.0).finish()
    }
}
pub const WAIT_FAILED: WAIT_EVENT = WAIT_EVENT(4294967295u32);
pub const WAIT_OBJECT_0: WAIT_EVENT = WAIT_EVENT(0u32);
pub const WAIT_TIMEOUT: WAIT_EVENT = WAIT_EVENT(258u32);
#[repr(transparent)]
#[derive(PartialEq, Eq, Copy, Clone, Default)]
pub struct WIN32_ERROR(pub u32);
impl windows_core::TypeKind for WIN32_ERROR {
    type TypeKind = windows_core::CopyType;
}
impl core::fmt::Debug for WIN32_ERROR {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("WIN32_ERROR").field(&self.0).finish()
    }
}
