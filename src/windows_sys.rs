// This file is autogenerated.
//
// To add bindings, edit windows_sys.lst then run:
//
// ```
// cd generate-windows-sys/
// cargo run
// ```
// Bindings generated by `windows-bindgen` 0.49.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
#[link(name = "advapi32")]
extern "system" {
    pub fn RegCloseKey(hkey: HKEY) -> WIN32_ERROR;
}
#[link(name = "advapi32")]
extern "system" {
    pub fn RegEnumKeyExW(
        hkey: HKEY,
        dwindex: u32,
        lpname: PWSTR,
        lpcchname: *mut u32,
        lpreserved: *const u32,
        lpclass: PWSTR,
        lpcchclass: *mut u32,
        lpftlastwritetime: *mut FILETIME,
    ) -> WIN32_ERROR;
}
#[link(name = "advapi32")]
extern "system" {
    pub fn RegOpenKeyExW(
        hkey: HKEY,
        lpsubkey: PCWSTR,
        uloptions: u32,
        samdesired: REG_SAM_FLAGS,
        phkresult: *mut HKEY,
    ) -> WIN32_ERROR;
}
#[link(name = "advapi32")]
extern "system" {
    pub fn RegQueryValueExW(
        hkey: HKEY,
        lpvaluename: PCWSTR,
        lpreserved: *const u32,
        lptype: *mut REG_VALUE_TYPE,
        lpdata: *mut u8,
        lpcbdata: *mut u32,
    ) -> WIN32_ERROR;
}
#[link(name = "kernel32")]
extern "system" {
    pub fn CreatePipe(
        hreadpipe: *mut HANDLE,
        hwritepipe: *mut HANDLE,
        lppipeattributes: *const SECURITY_ATTRIBUTES,
        nsize: u32,
    ) -> BOOL;
}
#[link(name = "ole32")]
extern "system" {
    pub fn CoCreateInstance(
        rclsid: *const GUID,
        punkouter: IUnknown,
        dwclscontext: CLSCTX,
        riid: *const GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> HRESULT;
}
#[link(name = "ole32")]
extern "system" {
    pub fn CoInitializeEx(pvreserved: *const ::core::ffi::c_void, dwcoinit: COINIT) -> HRESULT;
}
#[link(name = "oleaut32")]
extern "system" {
    pub fn SysFreeString(bstrstring: BSTR) -> ();
}
#[link(name = "oleaut32")]
extern "system" {
    pub fn SysStringLen(pbstr: BSTR) -> u32;
}
pub type ADVANCED_FEATURE_FLAGS = u16;
pub type BOOL = i32;
pub type BSTR = *const u16;
pub type CLSCTX = u32;
pub const CLSCTX_ALL: CLSCTX = 23u32;
pub type COINIT = i32;
pub const COINIT_MULTITHREADED: COINIT = 0i32;
pub const ERROR_NO_MORE_ITEMS: WIN32_ERROR = 259u32;
pub const ERROR_SUCCESS: WIN32_ERROR = 0u32;
#[repr(C)]
pub struct FILETIME {
    pub dwLowDateTime: u32,
    pub dwHighDateTime: u32,
}
impl ::core::marker::Copy for FILETIME {}
impl ::core::clone::Clone for FILETIME {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct GUID {
    pub data1: u32,
    pub data2: u16,
    pub data3: u16,
    pub data4: [u8; 8],
}
impl GUID {
    pub const fn from_u128(uuid: u128) -> Self {
        Self {
            data1: (uuid >> 96) as u32,
            data2: (uuid >> 80 & 0xffff) as u16,
            data3: (uuid >> 64 & 0xffff) as u16,
            data4: (uuid as u64).to_be_bytes(),
        }
    }
}
impl ::core::marker::Copy for GUID {}
impl ::core::clone::Clone for GUID {
    fn clone(&self) -> Self {
        *self
    }
}
pub type HANDLE = *mut ::core::ffi::c_void;
pub type HKEY = *mut ::core::ffi::c_void;
pub const HKEY_LOCAL_MACHINE: HKEY = invalid_mut(-2147483646i32 as _);
pub type HRESULT = i32;
pub const INVALID_HANDLE_VALUE: HANDLE = invalid_mut(-1i32 as _);
pub type IUnknown = *mut ::core::ffi::c_void;
pub const KEY_READ: REG_SAM_FLAGS = 131097u32;
pub const KEY_WOW64_32KEY: REG_SAM_FLAGS = 512u32;
pub type PCWSTR = *const u16;
pub type PWSTR = *mut u16;
pub type REG_SAM_FLAGS = u32;
pub const REG_SZ: REG_VALUE_TYPE = 1u32;
pub type REG_VALUE_TYPE = u32;
#[repr(C)]
pub struct SAFEARRAY {
    pub cDims: u16,
    pub fFeatures: ADVANCED_FEATURE_FLAGS,
    pub cbElements: u32,
    pub cLocks: u32,
    pub pvData: *mut ::core::ffi::c_void,
    pub rgsabound: [SAFEARRAYBOUND; 1],
}
impl ::core::marker::Copy for SAFEARRAY {}
impl ::core::clone::Clone for SAFEARRAY {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SAFEARRAYBOUND {
    pub cElements: u32,
    pub lLbound: i32,
}
impl ::core::marker::Copy for SAFEARRAYBOUND {}
impl ::core::clone::Clone for SAFEARRAYBOUND {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SECURITY_ATTRIBUTES {
    pub nLength: u32,
    pub lpSecurityDescriptor: *mut ::core::ffi::c_void,
    pub bInheritHandle: BOOL,
}
impl ::core::marker::Copy for SECURITY_ATTRIBUTES {}
impl ::core::clone::Clone for SECURITY_ATTRIBUTES {
    fn clone(&self) -> Self {
        *self
    }
}
pub const S_FALSE: HRESULT = 1i32;
pub const S_OK: HRESULT = 0i32;
pub type WIN32_ERROR = u32;

/// Adapted from
/// [`core::ptr::invalid_mut()`](https://doc.rust-lang.org/src/core/ptr/mod.rs.html#600-607).
///
/// This function should actually use `core::mem::transmute` but due to msrv
/// we use `as` casting instead.
///
/// Once msrv is bumped to 1.56, replace this with `core::mem::transmute` since
/// it is const stablised in 1.56
///
/// NOTE that once supports `strict_provenance` we would also have to update
/// this.
const fn invalid_mut<T>(addr: usize) -> *mut T {
    addr as *mut T
}
